//! Proactive Agent Loop ‚Äî background agent that monitors conditions and acts autonomously.
//!
//! The proactive agent periodically:
//! - Checks for pending plan tasks that need attention
//! - Evaluates workflow triggers
//! - Generates proactive summaries or alerts
//! - Monitors channel health
//!
//! ## Architecture
//! ```text
//! ProactiveLoop (tokio interval, default 5 min)
//!   ‚îú‚îÄ‚îÄ Check pending plans ‚Üí suggest next steps
//!   ‚îú‚îÄ‚îÄ Evaluate workflow events ‚Üí fire matching rules
//!   ‚îú‚îÄ‚îÄ Check agent idle time ‚Üí generate insights
//!   ‚îî‚îÄ‚îÄ Monitor channels ‚Üí report connectivity issues
//! ```

/// Configuration for the proactive agent loop.
#[derive(Debug, Clone)]
pub struct ProactiveConfig {
    /// How often to check (in seconds). Default: 300 (5 minutes).
    pub check_interval_secs: u64,
    /// Whether to auto-execute pending plan tasks.
    pub auto_execute_plans: bool,
    /// Whether to generate proactive summaries.
    pub proactive_summaries: bool,
    /// Whether to monitor channel health.
    pub monitor_channels: bool,
    /// Maximum number of proactive actions per cycle.
    pub max_actions_per_cycle: usize,
}

impl Default for ProactiveConfig {
    fn default() -> Self {
        Self {
            check_interval_secs: 300,
            auto_execute_plans: false,
            proactive_summaries: true,
            monitor_channels: true,
            max_actions_per_cycle: 3,
        }
    }
}

/// A proactive action generated by the loop.
#[derive(Debug, Clone)]
pub struct ProactiveAction {
    /// Action type: plan_reminder, summary, health_alert, workflow
    pub action_type: String,
    /// Human-readable description.
    pub description: String,
    /// Optional agent prompt to execute.
    pub agent_prompt: Option<String>,
    /// Priority (1=low, 5=critical).
    pub priority: u8,
}

/// The proactive agent loop context.
pub struct ProactiveLoop {
    config: ProactiveConfig,
    /// Tracks when the last proactive check ran.
    last_check: Option<chrono::DateTime<chrono::Utc>>,
    /// Action history (ring buffer, max 50).
    history: Vec<ProactiveAction>,
}

impl ProactiveLoop {
    /// Create a new proactive loop.
    pub fn new(config: ProactiveConfig) -> Self {
        Self {
            config,
            last_check: None,
            history: Vec::new(),
        }
    }

    /// Run one cycle ‚Äî check conditions and generate actions.
    /// Returns a list of proactive actions to execute.
    pub fn check_cycle(
        &mut self,
        pending_plan_count: usize,
        active_agent_count: usize,
        channel_statuses: &[(String, bool)], // (channel_name, is_connected)
    ) -> Vec<ProactiveAction> {
        let now = chrono::Utc::now();
        self.last_check = Some(now);

        let mut actions = Vec::new();

        // 1. Check pending plans
        if pending_plan_count > 0 {
            actions.push(ProactiveAction {
                action_type: "plan_reminder".to_string(),
                description: format!(
                    "üìã {} plan(s) have pending tasks. Consider reviewing and progressing them.",
                    pending_plan_count
                ),
                agent_prompt: Some(format!(
                    "There are {} plan(s) with pending tasks. List all plans and suggest which tasks should be started next.",
                    pending_plan_count
                )),
                priority: 2,
            });
        }

        // 2. Channel health monitoring
        if self.config.monitor_channels {
            let disconnected: Vec<&String> = channel_statuses
                .iter()
                .filter(|(_, connected)| !connected)
                .map(|(name, _)| name)
                .collect();

            if !disconnected.is_empty() {
                actions.push(ProactiveAction {
                    action_type: "health_alert".to_string(),
                    description: format!(
                        "‚ö†Ô∏è Disconnected channels: {}",
                        disconnected
                            .iter()
                            .map(|s| s.as_str())
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                    agent_prompt: None,
                    priority: 4,
                });
            }
        }

        // 3. Proactive summary (once per cycle if agents are active)
        if self.config.proactive_summaries && active_agent_count > 0 {
            let hour = now.format("%H").to_string().parse::<u32>().unwrap_or(0);
            // Only suggest summaries during business hours
            if hour == 8 || hour == 12 || hour == 17 {
                actions.push(ProactiveAction {
                    action_type: "summary".to_string(),
                    description: "üìä Time for a periodic status summary.".to_string(),
                    agent_prompt: Some(
                        "Generate a brief status summary of all active plans, recent activities, and any pending items that need attention.".to_string()
                    ),
                    priority: 1,
                });
            }
        }

        // 4. Limit actions per cycle
        actions.truncate(self.config.max_actions_per_cycle);

        // Record in history
        for action in &actions {
            self.history.push(action.clone());
            if self.history.len() > 50 {
                self.history.remove(0);
            }
        }

        actions
    }

    /// Get action history.
    pub fn history(&self) -> &[ProactiveAction] {
        &self.history
    }

    /// Get last check time.
    pub fn last_check(&self) -> Option<chrono::DateTime<chrono::Utc>> {
        self.last_check
    }

    /// Get config.
    pub fn config(&self) -> &ProactiveConfig {
        &self.config
    }
}

/// Spawn the proactive agent loop as a background tokio task.
/// Uses callbacks to avoid circular dependencies:
/// - `agent_callback`: sends a prompt and returns the response
/// - `state_callback`: returns (pending_plan_count, active_agent_count, channel_statuses)
pub async fn spawn_proactive_loop<F, Fut, S, SFut>(
    config: ProactiveConfig,
    agent_callback: F,
    state_callback: S,
) where
    F: Fn(String) -> Fut + Send + Sync + 'static,
    Fut: std::future::Future<Output = Result<String, String>> + Send,
    S: Fn() -> SFut + Send + Sync + 'static,
    SFut: std::future::Future<Output = (usize, usize, Vec<(String, bool)>)> + Send,
{
    let interval_secs = config.check_interval_secs;
    tracing::info!(
        "üß† Proactive agent loop started (check every {}s)",
        interval_secs
    );

    let mut ploop = ProactiveLoop::new(config);
    let mut interval = tokio::time::interval(std::time::Duration::from_secs(interval_secs));

    loop {
        interval.tick().await;

        // Gather current state
        let (pending_plans, agent_count, channel_statuses) = state_callback().await;

        // Run check cycle
        let actions = ploop.check_cycle(pending_plans, agent_count, &channel_statuses);

        if !actions.is_empty() {
            tracing::info!("üß† Proactive loop generated {} action(s)", actions.len());
        }

        // Execute proactive actions
        for action in &actions {
            tracing::info!(
                "  {} [{}] {}",
                match action.priority {
                    4..=5 => "üî¥",
                    3 => "üü°",
                    _ => "üü¢",
                },
                action.action_type,
                action.description
            );

            // If the action has an agent prompt, send it
            if let Some(prompt) = &action.agent_prompt {
                match agent_callback(prompt.clone()).await {
                    Ok(response) => {
                        tracing::info!(
                            "  ü§ñ Agent response: {}",
                            if response.len() > 200 {
                                format!("{}...", &response[..200])
                            } else {
                                response
                            }
                        );
                    }
                    Err(e) => {
                        tracing::warn!("  ‚ö†Ô∏è Agent prompt failed: {e}");
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proactive_loop_with_pending_plans() {
        let mut ploop = ProactiveLoop::new(ProactiveConfig::default());
        let actions = ploop.check_cycle(3, 1, &[]);
        assert!(!actions.is_empty());
        assert!(actions.iter().any(|a| a.action_type == "plan_reminder"));
    }

    #[test]
    fn test_proactive_loop_no_pending() {
        let mut ploop = ProactiveLoop::new(ProactiveConfig::default());
        let actions = ploop.check_cycle(0, 0, &[]);
        // No pending plans, no agents = minimal actions
        assert!(actions.iter().all(|a| a.action_type != "plan_reminder"));
    }

    #[test]
    fn test_channel_health_monitoring() {
        let mut ploop = ProactiveLoop::new(ProactiveConfig::default());
        let channels = vec![
            ("telegram".to_string(), true),
            ("discord".to_string(), false),
        ];
        let actions = ploop.check_cycle(0, 1, &channels);
        assert!(actions.iter().any(|a| a.action_type == "health_alert"));
    }
}
